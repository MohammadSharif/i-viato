# -----------------------------------------------------------------------------
# Name:     landmarks
# Purpose:  Given a .png image file, facial landmarks are detected and returned
#           The .png image must follow this naming pattern: 
#           videoId_frameNumber.png
#
# Author: Mohammad Sharif - Hirad Pourtahmasbi
#
# -----------------------------------------------------------------------------
import cv2
import dlib
import imutils
import argparse
import numpy as np
from pupils import find_eye_center

def rect_to_tuple(rect):
    """
    Meant to convert the dlib bounding rectangle prediction
    into a formatted tuple to be fed into OpenCV.
    return: tuple representing x,y,width, and height of rectangle
    """
    x = rect.left()
    y = rect.top()
    width = rect.width()
    height = rect.height()
    return (x, y, width, height)

def get_pupils(coords, image):
    """
    Takes in the list of coordinates generated by dlib and the image.
    return: list of tuples representing coordinates for pupils
    """
    print(coords[0])
    x1 = coords[36][0]
    y1 = max(coords[37][1], coords[38][1])
    w1 = coords[39][0] - x1
    h1 = min(coords[40][1], coords[41][1]) - y1
    left = image[y1:y1+h1, x1:x1+w1]
    center1 = find_eye_center(left)
    cx1, cy1 = center1
    center1 = (x1+cx1, y1 + cy1)
    x2 = coords[42][0]
    y2 = max(coords[43][1], coords[44][1])
    w2 = coords[45][0] - x2
    h2 = min(coords[47][1], coords[48][1]) - y2
    right = image[y2:y2+h2, x2:x2+w2]
    center2 = find_eye_center(right)
    cx2, cy2 = center2
    center2 = (x2 + cx2, y2 + cy2)
    return [center1, center2]

def shape_to_coord_list(shape, gray):
    """
    Takes the dlib face detection shape (the 68 coordinates) and
    converts it into a list of coordinates
    return: list of coordinates
    """
    # Create an empty list of 68 2-tuples
    coords = np.zeros((68,2), dtype="int")
    # Iterate over coords of shape and convert them into 2-tuples
    # Put the converted 2-tuples into the coords list
    for i in range(0, 68):
        coords[i] = (shape.part(i).x, shape.part(i).y)
    return coords

# Check if a point is inside a rectangle
def rect_contains(rect, point) :
    """
    Takes a bounding rectangle to make sure that the specified point is within
    the rectangle. This is used to ensure our delaunay triangles are drawn
    properly.
    return: boolean specifying if point is within the rectangle
    """
    if point[0] < rect[0] :
        return False
    elif point[1] < rect[1] :
        return False
    elif point[0] > rect[2] :
        return False
    elif point[1] > rect[3] :
        return False
    return True

# Draw delaunay triangles
def draw_delaunay(img, subdiv, delaunay_color) :
    triangleList = subdiv.getTriangleList();
    size = img.shape
    rect = (0, 0, size[1], size[0])
    for t in triangleList:
        pt1 = (t[0], t[1])
        pt2 = (t[2], t[3])
        pt3 = (t[4], t[5])
        if rect_contains(rect, pt1) and rect_contains(rect, pt2) and rect_contains(rect, pt3) :
            cv2.line(img, pt1, pt2, delaunay_color, 1, cv2.LINE_AA, 0)
            cv2.line(img, pt2, pt3, delaunay_color, 1, cv2.LINE_AA, 0)
            cv2.line(img, pt3, pt1, delaunay_color, 1, cv2.LINE_AA, 0)

# The following 4 lines set up our argument capabilities via commandline
ap = argparse.ArgumentParser()
ap.add_argument("-p", "--predictor", required=True, help="Path to landmark predictor")
ap.add_argument("-i", "--image", required=True, help="Path to image file")
args = vars(ap.parse_args())

# We initialize the dlib face detector and create the landmark predictor
detector = dlib.get_frontal_face_detector()
# This is a function that we can call later on a shape
predictor = dlib.shape_predictor(args["predictor"])

# For better detection we need to get the image resizes and converted to grayscale
image = cv2.imread(args["image"])
# image = small = cv2.resize(image, (0,0), fx=0.5, fy=0.5)
size = image.shape
rect = (0, 0, size[1], size[0])
subdiv  = cv2.Subdiv2D(rect);
gray = cv2.imread(args["image"], 0)

# We run the detection on the grayscale version of the image
# Notice the variable "rects" is plural this is because there may
# be mutliple faces detected within the image
rects = detector(gray, 1)

# Add each frames data to this list so we can write to db in the end
# Loop over all detected faces in the image
for i, rect in enumerate(rects):
    # get the detections and convert them into a numpy array
    shape = predictor(gray, rect)
    # A list of 68 2-tuples representing facial landmark coordinates
    shape = shape_to_coord_list(shape, gray)
    # A list of two elements which are 2-tuples representing pupil coordinates.
    pupils = get_pupils(shape, gray)
    """
    @Hirad: The shape variable above this comment contains the list of coords
    for the facial landmark detection. That would be what needs to get pushed
    into the DB.

    The "pupils" variable is a list of 2 elements (each eye) the elements are
    2-tuples representing the eye coordinates.

    pupils[0] == left eye (relative to user point of view of image)
    pupils[1] == right eye (relative to user point of view of image)
    """
    # draw facial landmarks on the image
    for x, y in shape:
        print("(" + str(x) + ", " + str(y) +")")
        cv2.circle(image, (x, y), 2, (255, 255, 255), -1)
        subdiv.insert((x,y))
    draw_delaunay( image, subdiv, (255, 255, 255))

# show the output image with detections and landmarks
image = small = cv2.resize(image, (0,0), fx=0.5, fy=0.5)
cv2.imshow("Output", image)
cv2.waitKey(0)
